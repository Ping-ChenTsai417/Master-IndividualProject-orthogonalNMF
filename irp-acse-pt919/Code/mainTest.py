""" 
Run this moduel to test the software.
The software apply non-negative matrix factorization with sparsity control scheme proposed by Hoyer(2004)

"""
# Author: Ping-Chen Tsai, Aug 2020 

import NMF_Sparse
import label_Pixel
import validate_Accuracy
import numpy as np
from math import sqrt
import scipy.io
from sklearn.cluster import KMeans
import imageio

# Import data
mypath = 'C:/Users/Tsaip//OneDrive - Imperial College London/Ovation Data Internship 2020/Data/ContenSimilarityTest/images_Landmass.mat'
list_data = scipy.io.loadmat(mypath)['images']
array_data = np.array(list_data)

# Define parameters
NumOfClasses = 4 # number of class input
classL = [0, 1, 2, 3] # Labels. should be starting from 0 !!! Cannot be random integers
classL_acc = [0, 2, 3] # Class labels for accuracy test. 
                       # For landmass, We only class 0, 2, and 3 accuracy because we don't have ground truth of 'unknown' class
                       
k_clusters = 250 # feature numbers selected by users, or elbow's method
numImages = array_data.shape[0] # numImages is total num of images
numImagesPerClass = [500, 500, 500, 500] # Same number of images per class for LANDMASS.
set_sparsity = 0.5125 # target sparsity. Tune it 
alpha_ = 0.0575 # Regularization intensity for running NMF model. User can tune it

# Image shape:(width, length)
width = array_data[0].shape[0]
length = array_data[0].shape[1]
del list_data, mypath # Save memory
# Plot five images of each class, uncomment the following to to plot
# NMF_Sparse.plt_boxData(classL, numImagesPerClass, numImages, width, length, array_data = array_data)

# Create data matrix X. Reshape data matrix for NMF input
X = np.reshape(array_data,(numImages,width*length)).T
print('Data matrix X shape: ', X.shape)
# Check if there is negative element in the matrix. The dataset should be normalised to [0, 1]
if (X < 0).any():
    print('Matrix elements are not all positive!')

# split data matrix to classes for factors initialisation
X_class = NMF_Sparse.splitX(X, classL, numImagesPerClass)

#  Run Kmeans for initialisation
kmeans = []
print('Running Kmeans for initialisation...')
for i in np.arange(NumOfClasses):
    kmeans.append(KMeans(n_clusters=k_clusters, max_iter=1000).fit(X_class[i].T)) # Perform kmeans on each dataset features
print('=== Finished ===')
del X_class # save memory


# Initialise W and H for the whole dataset
W_init, H_init = NMF_Sparse.initialise_WH(width, length, kmeans, NumOfClasses, k_clusters, numImages)

# Sparsity column
N_p = len(X) # Number of pixels for single image

L1toL2 = sqrt(N_p) - sqrt(N_p-1)*set_sparsity # L1L2ratio, according to Hoyer(2004)
W_init = NMF_Sparse.sparcify_columns(W_init, set_sparsity)

W_all, H_all = NMF_Sparse.nmf_allClass(X, NumOfClasses, k_clusters, W_init, H_init, alpha = alpha_, l1_ratio = L1toL2)
del W_init, H_init # save memory

# Plot representation generated by NMF with sparseness constraints
# Uncomment follwowing to plot

# WH_product = np.dot(W_all, H_all)
# NMF_Sparse.plt_boxData(classL, numImagesPerClass, numImages, width, length, WH_product = WH_product)
# del WH_product # save memory

# Generate likelihood matrix 
Y = label_Pixel.get_likelihoodMatrix(W_all, H_all, NumOfClasses, k_clusters, numImages, width, length)

background = True # Choose if the label includes 'background', background indicates no traps
if background:
    bkgrd_label = NumOfClasses+1 
else:
    bkgrd_label = NumOfClasses-1

# Extract pixel label coordinations
classified_all = label_Pixel.extract_coordination(Y, NumOfClasses, numImages, width, length, bkgrd_label,
                         gaussian_filtering = True, median_filtering = True, sigma = 0.9) # User can change the sigma for gaussian filter
del Y

# split labelled result
classN = label_Pixel.split_labelResult(classified_all, NumOfClasses, bkgrd_label, background=True)

# Assign colors to labels. plot the labels
# In order: blue chaotic; light blue unkown; green fault ; red salt; grey background
colorarr = np.array([[0,0,255],[100,255,255], [0,255,0], [255,0,0], [183,183,183]])
# set plot = True to plot colorred pixel labels
color_img = label_Pixel.plotLabels(classL, numImagesPerClass,numImages, width, length, classN, array_data, colorarr, plot = False) 

# Create binary masks for each class. From the mask coordinations, we extract only the correct predicted labelled pixels out
class_mask = label_Pixel.createBinaryMask(classL, classN, numImages, width, length, numImagesPerClass, plotMask = False) 

# Save each class of mask into different folder
# Path order should be the same as the order you put in data matrix X
path1 = 'C:/Users/Tsaip/OneDrive - Imperial College London/Ovation Data Internship 2020/Data/ContenSimilarityTest/predicted mask/chaotic/'
path2 = 'C:/Users/Tsaip/OneDrive - Imperial College London/Ovation Data Internship 2020/Data/ContenSimilarityTest/predicted mask/unknown/'
path3 = 'C:/Users/Tsaip/OneDrive - Imperial College London/Ovation Data Internship 2020/Data/ContenSimilarityTest/predicted mask/fault/'
path4 = 'C:/Users/Tsaip/OneDrive - Imperial College London/Ovation Data Internship 2020/Data/ContenSimilarityTest/predicted mask/salt/'
maskPath = [path1, path2, path3, path4]

# Save masks to paths
label_Pixel.save_toPath(maskPath, class_mask, classL, numImagesPerClass)

# Checking accuracy
mask_truth, maskNum = validate_Accuracy.importMask(width, length)


y_truth, y_pred = validate_Accuracy.get_Ypred_Ytrue(mask_truth, classL_acc, 
                                                    classified_all, maskNum, numImagesPerClass, bkgrd_label)

# Uncomment the following to plot prediction vs ground truth for a single image
# imgIdx = 5 #image indx to plot
# validate_Accuracy.plotPredvsGT(mask_truth, numImagesPerClass, array_data, color_img, classL_acc, maskNum, imgIdx = imgIdx)

del mask_truth #save memory

# Get Jaccard index and accuracy scores
jaccard_score, accuracy_ = validate_Accuracy.getAccuracy(y_truth, y_pred, classL_acc)

